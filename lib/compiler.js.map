{"version":3,"sources":["../src/compiler.js"],"names":["compile","str","opts","module","cc","CompilerContext","errors","node","methods","constructor","name","expr","msg","error","id","exported","decls","exports","Module","importList","import_","declList","decl","Import","require","moduleSpec","item","origId","declare","localId","compileImportExpression","Const","value","LogicalOr","items","map","i","LogicalAnd","ChainedCall","calls"],"mappings":"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","file":"compiler.js","sourcesContent":["import { parse } from './parser'\r\n\r\nexport function compile (str, opts = {}) {\r\n  const module = parse(str)\r\n  if (!module) return null\r\n  const cc = new CompilerContext(module, opts)\r\n  cc.compile(module)\r\n  return cc.errors === 0 ? module : null\r\n}\r\n\r\nclass CompilerContext {\r\n  constructor (module, opts) {\r\n    this.module = module\r\n    this.opts = opts\r\n    this.errors = 0\r\n  }\r\n\r\n  compile (node) {\r\n    return methods[node.constructor.name](this)\r\n  }\r\n\r\n  compileImportExpression (expr) {\r\n    // todo: check type of import and handle accordingly\r\n    return expr\r\n  }\r\n\r\n  error (msg) {\r\n    this.errors++\r\n    this.opts.error && this.opts.error(msg)\r\n  }\r\n\r\n  declare (id, expr, exported) {\r\n    if (id in this.module.decls) {\r\n      this.error(`${id}: duplicate identifier`)\r\n    } else {\r\n      this.module.decls[id] = expr\r\n      if (exported) {\r\n        this.module.exports[id] = expr\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nconst methods = {\r\n\r\n  Module (cc) {\r\n    for (let import_ of this.importList) {\r\n      import_.compile(cc)\r\n    }\r\n    for (let decl of this.declList) {\r\n      decl.compile(cc)\r\n    }\r\n    return this\r\n  },\r\n\r\n  Import (cc) {\r\n    const module = require(this.moduleSpec)\r\n    for (let item of this.importList) {\r\n      if (item.origId in module) {\r\n        cc.declare(item.localId, cc.compileImportExpression(module[item.origId]))\r\n      } else {\r\n        cc.error(`${item.origId}: identifier not defined in module '${this.moduleSpec}`)\r\n      }\r\n    }\r\n  },\r\n\r\n  Const (cc) {\r\n    cc.declare(this.id, cc.compile(this.value), this.exported)\r\n  },\r\n\r\n  LogicalOr (cc) {\r\n    this.items = this.items.map(i => cc.compile(i))\r\n    return this\r\n  },\r\n\r\n  LogicalAnd (cc) {\r\n    this.items = this.items.map(i => cc.compile(i))\r\n    return this\r\n  },\r\n\r\n  ChainedCall (cc) {\r\n    this.calls = this.calls.map(i => cc.compile(i))\r\n    return this\r\n  }\r\n}\r\n"]}