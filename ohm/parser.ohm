
JSONdecl {

	// module

	Module =
		| Import* Declaration* ~Declarator Expression #term -- def
		| Import* Declaration* -- nodef

	Import =
		| "import" "{" ListOf<ImportItem, ","> "}" "from" string #term -- list

	ImportItem =
		| identifier -- simple

	Declaration =
		| "const" identifier "=" Expression #term -- const
		| "export" "const" identifier "=" Expression #term -- export_const
		| "export" "default" Expression #term -- export_default

	// expressions

	Expression = LogicalOr

	LogicalOr = NonemptyListOf<LogicalAnd, "|">

	LogicalAnd = NonemptyListOf<LogicalNot, "&">

	LogicalNot = "!"* Primary

	Primary =
		| Literal
		| Grouping
		| Chain

	Literal =
		| Object
		| Array
		| number
		| String
		| regexp
		| constant

	Grouping = "(" Expression ")"	

	Chain = NonemptyListOf<(Call|Ref), ".">

	Ref = identifier

	Call = identifier "(" ListOf<Expression, ","> ")"

	Object (an object) = "{" ListOf<Property, ","> "}"

	Array (an array) = "[" ListOf<ListItem, ","> "]"

	String = string

	// helpers

	Property (a property) = Expression ":" Expression

	ListItem (a list item) = Expression

	Declarator = "import" | "export" | "const"

	// lexical rules

	space := "\t" | " " | "\n" | "\r" | comment
	spaceInline = "\t" | " " | commentInline
	comment = blockComment | lineEndComment
	commentInline = blockCommentInline | lineEndComment
	blockComment = "/*" (~"*/" any)* "*/"
	blockCommentInline = "/*" (~("*/" | "\n" | "\r") any)* "*/"
	lineEndComment = "//" (~("\n" | "\r") any)*
	term =
		| space* (";" | end)
		| spaceInline* ("\r" | "\n" | end)

	identifier (an indentifier) = identifierStart identifierPart*
	identifierStart = "A".."Z" | "a".."z" | "_"
	identifierPart = identifierStart | digit

	number (a number) = "-"? integerPart ("." fractionalPart)? exponentPart?
	integerPart = positiveInteger | "0"
	positiveInteger = nonZeroDigit digit*
	fractionalPart = digit+
	exponentPart = ("e" | "E") ("+" | "-")? digit+
	nonZeroDigit = "1".."9"

	string (a string) = "\"" stringCharacter* "\""
	stringCharacter = normalChar | escapeSequence
	normalChar = ~("\"" | "\\" | "\u0000".."\u001f") any
	escapeSequence = "\\" escapeSpec
	escapeSpec =
		| "\""
		| "\\"
		| "\\/"
		| "b"
		| "f"
		| "n"
		| "r"
		| "t"
		| unicodeEscapeSpec
	unicodeEscapeSpec = "u" hexDigit hexDigit hexDigit hexDigit

	regexp (a regular expression) = "/" regexpBody "/" regexpFlags
	regexpBody = ("\\/" | ~"/" any)+
	regexpFlags = ("A".."Z" | "a".."z")*

	constant =
		| "this" -- this
		| "null" -- null
		| "true" -- true
		| "false" -- false
}

